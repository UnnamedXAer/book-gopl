
ptg16091132SECTION 4.2. SLICES 91Up dat ingthe slice variableisrequired not justwhencal lingappend,but for any  functionthatmaychange the lengt hor cap acity ofaslice ormakeitrefer toadif ferentunderly ing array.Tous eslices correc tly,it’simp ortanttobearinmindthatalt hough the elements ofthe underly ingar ray areindirec t,the slice’spoint er,  lengt h, andcap acity are not.Toupdatethemrequires anassig nmentlikethe one above .In thisrespect,slices arenot‘‘pure’’referencetyp esbutres em-bleanaggregatetyp esuch asthisstr uct:type IntSlice struct {ptr   *intlen, cap int}OurappendIntfunc tionaddsasingleelementtoaslice,but  the  bui lt-inappendlets  usaddmore thanone newelement, orevenawhole slice ofthem.var x []intx=append(x, 1)x=append(x, 2, 3)x=append(x, 4, 5, 6)x=append(x, x...) // append the slice xfmt.Println(x)   // "[1 2 3 4 5 6 1 2 3 4 5 6]"Wi ththe small modification  shown below,wecan match the beh avior  of  the bui lt-inappend.Theellipsis‘‘...’’in the declarat ionofappendIntmakesthe functionvariadic:itaccepts anynumb erof finalarguments.  Thecor respondingellipsisinthe cal lab ove toappendshows howto  sup ply  a  listofarguments  fro maslice.We’ll  explain  thismechanism  in  detai l  inSection5.7.func appendInt(x []int, y ...int) []int {var z []intzlen := len(x) + len(y)// ...expand z to at least zlen...copy(z[len(x):], y)return z}Thelog icto exp andz’sunderly ing array remainsunchange dandisnot shown.4.2.2. In-PlaceSliceTechniquesLet’ssee moreexamples offunctions that, likerotateandreverse,modif ytheelements ofaslice in place.Given a list ofstr ings, thenonemptyfunc tionretur nsthe non-empt yon es:gopl.io/ch4/nonempty// Nonempty is an example of an in-place slice algorithm.package mainimport "fmt"The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg1609113292 CHAPTER4.  COMPOSITE TYPES// nonempty returns a slice holding only the non-empty strings.// The underlying array is modified during the call.func nonempty(strings []string) []string {i:=0for _, s := range strings {if s != "" {strings[i] = si++}}return strings[:i]}Thesubtlepar tis  thatthe  inp utslice  andthe  out put  slice  share  the  sameunderly ing  array.Thisavoidsthe need toallocateanother array,thoug hof cours ethecontentsofdataarepar tlyov erwritt en, as evidence dby the secon dpr int statement:data := []string{"one", "", "three"}fmt.Printf("%q\n", nonempty(data)) //`["one" "three"]`fmt.Printf("%q\n", data)//`["one" "three" "three"]`Thus wewou ldusu allywrite:data = nonempty(data).Thenonemptyfunc tioncan also bewritt enusingappend:func nonempty2(strings []string) []string {out := strings[:0] // zero-length slice of originalfor _, s := range strings {if s != "" {out = append(out, s)}}return out}Whiche ver variant  weuse,reusinganarray in thisway requires thatatmostone out put valueis pro duce dforeachinp utvalue,whichistrueofmanyalgor it hms that filt erout elements ofasequence  orcom bine  adj acentones.  Suchint ric ateslice  usage  isthe  exception,not  the  rule,butitcan becle ar,efficient, andusefulonocc asion.Aslice can beusedtoimp lementastack.Given an initial lyemp tyslicestack,wecan pushane wvalue ont otheend ofthe slice wit happend:stack = append(stack, v) // push vThetop ofthe stack isthe lastelement:top := stack[len(stack)-1] // top of stackandshr inking the stack bypoppingthatelementisstack = stack[:len(stack)-1] // popThe Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg16091132SECTION 4.3. MAPS 93To  remov ean  elementfro mthemidd leof  a  slice,preservingthe  order  ofthe  remainingele-ments, usecopyto slide the hig her-numbere delements down byone to fill the gap:func remove(slice []int, i int) []int {copy(slice[i:], slice[i+1:])return slice[:len(slice)-1]}func main() {s:=[]int{5, 6, 7, 8, 9}fmt.Println(remove(s, 2)) // "[5 6 8 9]"}Andifwedon’tneed topreservethe order,wecan justmov ethelastelementint othegap:func remove(slice []int, i int) []int {slice[i] = slice[len(slice)-1]return slice[:len(slice)-1]}func main() {s:=[]int{5, 6, 7, 8, 9}fmt.Println(remove(s, 2)) // "[5 6 9 8]}Exercis e 4.3:Re writ ereverseto use anarray point erins teadofaslice.Exercis e 4.4:Wr ite a versionofrotatethat operates in a singlepass.Exercis e 4.5:Wr ite anin-place functiontoeliminateadj acentdup lic ates in a[]stringslice.Exercis e 4.6:Wr ite  anin-place  functionthatsqu asheseachrun  ofadj acentUnico desp aces(s eeunicode.IsSpace)inaUTF-8-enco ded[]byteslice into a singleASCII space.Exercis e 4.7:Mo dif yreverseto  reverse  the  charac tersofa[]byteslice  thatrepresentsaUTF-8-enco dedstr ing ,in place.Can you doitwit houtallocat ingnew memor y?4.3. MapsThehashtable  isone  ofthe  most  ingenious  and  versatileofall  dat ast ruc tures.   Itisanunordered col lec tion of key/value pairsinwhichall the keysare distinc t,and the value asso ci-ated wit hagiven  key can  beret rie ved,updated,orremov edusingacon stant  numb erofkeycomp arisons onthe average, nomatterhow large the hashtable.In  Go,  amapis a reference toahashtable,and a map typ eis writt enmap[K]V,whereKandVarethe typ esof itskeysand values.  All ofthe keysinagiven map areofthe sametyp e,and allof the values areofthe sametyp e,but the keysneed not beofthe sametyp eas the values.  Theke ytypeKmu stbecomparable using==,sothatthe map can testwhether a given key isequ alto  one  already  wit hin  it.   Thoughfloating-p ointnumbers  are  comparable,it’sabad  ideatocomp arefloats for equ ality and,aswemention edinChapt er3,esp eci ally bad if NaN isapos-siblevalue.There are norestr ictions onthe value typ eV.The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg1609113294 CHAPTER4.  COMPOSITE TYPESThebui lt-in functionmakecanbeusedtocre ate a map:ages := make(map[string]int) // mapping from strings to intsWe  can also use amaplit era lto cre ate a new map popu lated wit hsome initial key/value pairs:ages := map[string]int{"alice":  31,"charlie": 34,}Thisisequivalenttoages := make(map[string]int)ages["alice"] = 31ages["charlie"] = 34so analt ernat ive expressionfor a new emp tymap ismap[string]int{}.Mapelements areaccessedthrough the usu alsubscript not ation:ages["alice"] = 32fmt.Println(ages["alice"]) // "32"andremov edwit hthebui lt-in functiondelete:delete(ages, "alice") // remove element ages["alice"]Al lof these operat ions are  safeevenifthe elementisn’tinthe map; a map lookup usingakeythat isn’tpresent  retur nsthe zerovalue for  itstyp e,so,  for  ins tance,the fol low ing  worksevenwhen"bob"is not yet a key inthe map because the value ofages["bob"]wi l lbe0.ages["bob"] = ages["bob"] + 1 // happy birthday!Theshorthand  assig nmentfor msx+=yandx++also  wor kformap  elements,  sowecan  re-wr ite the statement above asages["bob"] += 1or evenmorecon cis ely asages["bob"]++Butamap elementisnot a var iable,and wecannot takeits address:_=&ages["bob"] // compile error: cannot take address of map elementOnereasonthatwecan’ttakethe addressofamap elementisthatgrowing a map might causere hashingofexist ing  elements  into  new  storagelocat ions,thu spotent ial lyinvalid atingtheaddress.To  enumerateall  the  key/value  pairsinthe  map,weuse  arange-b asedforlo opsimi lar  tothos ewe  saw  for  slices.  Successive  iterat ions  ofthe  loopcause thenameandagevar iables  tobe set tothe next key/value pair :The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg16091132SECTION 4.3. MAPS 95for name, age := range ages {fmt.Printf("%s\t%d\n", name, age)}Theorder ofmap iterat ionisuns pecified,and dif ferentimp lementation smig htuse a dif ferenthash function, leadingtoadif ferentorder ing.  Inprac tice,the order israndom, varying fro mon eexec ution tothe next.  Thisisint ent ion al; mak ingthe sequence varyhelps force programsto berobustacrossimp lementation s.Toenumeratethe key/value pairsinorder,wemustsor tthekeysexplicitly,  for ins tance,usingtheStringsfunc tionfro mthesortpackageifthe keysarestr ings.  Thisisacommonpattern:import "sort"var names []stringfor name := range ages {names = append(names, name)}sort.Strings(names)for _, name := range names {fmt.Printf("%s\t%d\n", name, ages[name])}Sinceweknowthefinalsize ofnamesfrom the outset, itismoreefficienttoallocateanarray oftherequired  size  upfro nt.  Thestatement  below  cre atesaslice  thatisinitial lyemp tybut  hassufficientcap acity toholdall the keysoftheagesmap:names := make([]string, 0, len(ages))In thefirs trangelo opabove ,we requireonlythe keysoftheagesmap,  soweomitthe secon dlo opvar iable.Inthe  secon dlo op,  werequireonlythe  elements  ofthenamesslice,soweusetheblank identifier_to ignorethefirs tvar iable,the index.Thezerovalue for a map typ eisnil,thatis, a reference tonohashtable at all.var ages map[string]intfmt.Println(ages == nil)  // "true"fmt.Println(len(ages) == 0) // "true"Most  operat ions  onmaps,  includinglooku p,delete,len,andrangelo ops,  aresafetoper-form  onanil  map  reference,since  itbeh aveslikeanemp tymap.But  storing  toanil  mapcaus esapanic:ages["carol"] = 21 // panic: assignment to entry in nil mapYo umu stallocatethe map beforeyou can store int oit.Accessingamap  elementbysubscript ing  always  yieldsavalue.Ifthe  key  ispresent  inthemap,  you get the cor respondingvalue; if not,you get the zerovalue for the elementtyp e,aswesawwit hages["bob"].For  manypur pos esthat’s  fine,but  som etimesyou  need  toknowwhet her the elementwas reallythere ornot.For example, ifthe elementtyp eis numer ic,youmig hthavetodistinguish bet weenanon existentelementand anelementthathappens tohavethevalue zero, usingatestlikethis:The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg1609113296 CHAPTER4.  COMPOSITE TYPESage, ok := ages["bob"]if !ok { /* "bob" is not a key in this map; age == 0. */ }Yo u’ll often see these two statementscom bine d,likethis:if age, ok := ages["bob"]; !ok { /* ... */ }Su bscript ing  a  map  in  thiscontext  yieldstwo  values;  the  secon dis  a  boole anthat  rep ortswhet her  the  elementwas  present.The  boole an  var iable  isoften  cal le dok,esp eci ally  ifitisimmediate lyusedinanifcondit ion.As wit hslices, maps cannot becompare dto eachother ;theonlylegal comp arisoniswit hnil.To   testwhether  two  maps  cont ain  the  samekeysand  the  sameass oci ated  values,  wemustwr ite a loop:func equal(x, y map[string]int) bool {if len(x) != len(y) {return false}for k, xv := range x {if yv, ok := y[k]; !ok || yv != xv {return false}}return true}Observehow  weuse!okto  distinguish  the‘‘missing’’and‘‘pres entbut  zero’’cases.  Had  wenaïvelywritt enxv != y[k],the cal lbelowwou ldincor rec tly rep ort its arguments as equ al:// True if equal is written incorrectly.equal(map[string]int{"A": 0}, map[string]int{"B": 42})Go doesnot provide asettype,but since the keysofamap aredistinc t,amap can ser vethispurpos e.Toillustrate,  the  programdedupre ads  a  sequence  oflines  andprintsonlythefirs toccurrence  ofeachdistinc tline.   (It’savar iantofthedupprog ramthat  weshowe dinSection1.3.)  Thededupprog ramus esamap  whose keysrepresent  the  set  oflines  thathavealready app eared toens ure thatsubsequentocc urrences arenot print ed.gopl.io/ch4/dedupfunc main() {seen := make(map[string]bool) // a set of stringsinput := bufio.NewScanner(os.Stdin)for input.Scan() {line := input.Text()if !seen[line] {seen[line] = truefmt.Println(line)}}The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg16091132SECTION 4.3. MAPS 97if err := input.Err(); err != nil {fmt.Fprintf(os.Stderr, "dedup: %v\n", err)os.Exit(1)}}Go programmersoften descr ibe a map usedinthisfashionasa‘‘setofstr ings’’withoutfur therado,but beware, not allmap[string]boolvalues aresimplesets; som emaycontain bot htrueandfalsevalues.Sometimesweneed a map orset whose keysare slices, but because a map’skeysmustbecom-parable,thiscannot  beexpress eddirec tly.How ever,  itcan  bedon ein  two  steps.   First  wedefine a helperfunctionkthat maps eachkey toastr ing ,with thepro per tythatk(x) == k(y)if  andonlyifwecon siderxandyequivalent.  Then  wecre ate  a  map  whose keysare  str ings,apply ing the helperfunctiontoeachkey beforeweaccessthe map.Theexamplebelow usesamap torecordthe numberoftimesAddhasbeencal le dwith a givenlist  ofstr ings.  Itusesfmt.Sprintfto  convert  a  slice  ofstr ingsint oasinglestr ing  thatisasuit ablemap key,quoting eachslice elementwit h%qto recordstr ing bound aries faithfully:var m = make(map[string]int)func k(list []string) string { return fmt.Sprintf("%q", list) }func Add(list []string){m[k(list)]++ }func Count(list []string) int { return m[k(list)] }Thesameappro ach  can  beusedfor  any  non-comp arable  key  typ e,not  justslices.   It’sevenus efulfor comparable key typ eswhen you wantadefinition of equ ality other than==,suchascase-insensit ive  comparisons  for  str ings.  And  the  typ eofk(x)ne e dn’tbeastr ing;any  com-parable typ ewith thedesired equivalence pro per tywill do, suchasint egers,arrays, orstr ucts.Here’sanother exampleofmaps in action,aprogram thatcountsthe occ urrences ofeachdis-tinc tUnico de co depointinits  input.  Since  there  are  a  large  numberofpossiblecharac ters,on lyasmall  frac tionofwhichwou ldapp ear  in  anypar tic ulardocument,  a  map  isanaturalway tokeeptrackofjustthe onesthathavebeenseenand their correspondingcounts.gopl.io/ch4/charcount// Charcount computes counts of Unicode characters.package mainimport ("bufio""fmt""io""os""unicode""unicode/utf8")The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg1609113298 CHAPTER4.  COMPOSITE TYPESfunc main() {counts := make(map[rune]int)  // counts of Unicode charactersvar utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodingsinvalid := 0// count of invalid UTF-8 charactersin := bufio.NewReader(os.Stdin)for {r, n, err := in.ReadRune() // returns rune, nbytes, errorif err == io.EOF {break}if err != nil {fmt.Fprintf(os.Stderr, "charcount: %v\n", err)os.Exit(1)}if r == unicode.ReplacementChar && n == 1 {invalid++continue}counts[r]++utflen[n]++}fmt.Printf("rune\tcount\n")for c, n := range counts {fmt.Printf("%q\t%d\n", c, n)}fmt.Print("\nlen\tcount\n")for i, n := range utflen {if i > 0 {fmt.Printf("%d\t%d\n", i, n)}}if invalid > 0 {fmt.Printf("\n%d invalid UTF-8 characters\n", invalid)}}TheReadRunemethod perfor msUTF-8 deco dingand retur nsthree values: the decoded rune,thelengt hin bytes ofits UTF-8 enco ding, and anerror value.The onlyerror weexp ect isend-of-file.Ifthe  inp utwas  not  a  legal  UTF-8  enco dingofarune,  the  retur ned  runeisuni-code.ReplacementCharandthe lengt his 1.Thecharcountprog ram  also  printsacount  ofthe  lengt hsofthe  UTF-8  enco dings  oftherunesthatapp eared inthe inp ut.  Amapisnot the bestdat ast ruc turefor that; since enco dinglengt hsrange onlyfro m1toutf8.UTFMax(w hichhas the value 4), an array ismorecompact.As  anexp eriment, werancharcounton  thisbookits elf at one point.Alt hough it’smostlyinEnglish, ofcours e,it doeshaveafair numberofnon-ASCII charac ters.  Hereare the top ten:°27B15F14  é  13A10<5&5D4(4+3The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg16091132SECTION 4.4. STRUCTS99andhereisthe distr ibution of the lengt hsofall the UTF-8 enco dings:len count176539126037040Thevalue typ eof a map can its elf beacomposite typ e,suchasamap orslice.Inthe fol low ingco de,the key typ eofgraphisstringandthe value typ eismap[string]bool,represent ing asetofstr ings.  Con ceptu ally,graphmaps a str ing toaset ofrel ate dst rings, its successors inadirec ted graph.gopl.io/ch4/graphvar graph = make(map[string]map[string]bool)func addEdge(from, to string) {edges := graph[from]if edges == nil {edges = make(map[string]bool)graph[from] = edges}edges[to] = true}func hasEdge(from, to string) bool {return graph[from][to]}TheaddEdgefunc tionshows  the  idiomaticway  topopu lateamap  lazi ly,  thatis,  toinitializeeach  value  as  its  key  app earsfor  thefirs ttime.ThehasEdgefunc tionshows  how  the  zerovalue  ofamissingmap  entr yis  often  put  towor k:evenifneitherfromnortois  present,graph[from][to]wi l lalways giveameaningf ulresu lt.Exercis e 4.8:Mo dif ycharcountto count letters,dig its, andsoonintheir Unico decategories,usingfunctions likeunicode.IsLetter.Exercis e 4.9:Wr ite a programwordfreqto rep ort the fre quency ofeachwordinaninp uttextfile.Cal linput.Split(bufio.ScanWords)before thefirs tcall toScanto bre akthe inp utint oword sinsteadoflines.4.4. StructsAst ruc tis anaggregatedat atype thatgro ups toget her zeroormorenamed values ofarbit rar ytypesasa singleent ity.Eachvalue iscal le d afiel d.The classic exampleofastr uct fro mdataprocessingisthe emp loy eerecord, whosefields are a unique ID,the emp loy ee’sname, address,date ofbir th, position,sal ary,  manager,and the like.  All ofthesefields are col lec ted int oasin-gleent ity  thatcan  becopie das  a  unit,  passedtofunctions  and  retur ned  bythem,  store dinar rays, andsoon.The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
ptg16091132100 CHAPTER4.  COMPOSITE TYPESThes etwostatementsdeclare a str uct typ ecalledEmployeeandavar iable cal le ddilbertthatis anins tance ofanEmployee:type Employee struct {ID    intName   stringAddress  stringDoB    time.TimePosition  stringSalary  intManagerID int}var dilbert EmployeeTheindiv idu al  fields  ofdilbertareaccessedusingdot  not ation  likedilbert.Nameanddilbert.DoB.Becausedilbertis a var iable,its fields are var iables too,sowemay assig nto afield:dilbert.Salary -= 5000 // demoted, for writing too few lines of codeor takeits addressand accessitthrough a point er:position := &dilbert.Position*position = "Senior " + *position // promoted, for outsourcing to ElboniaThedot not ation als oworkswit hapoint ertoastr uct:var employeeOfTheMonth *Employee = &dilbertemployeeOfTheMonth.Position += " (proactive team player)"Thelaststatement isequivalentto(*employeeOfTheMonth).Position += " (proactive team player)"Gi venanemp loy ee’sunique ID,the functionEmployeeByIDreturnsapoint ertoanEmployeest ruc t.We  can use the dot not ation toaccessits fields:func EmployeeByID(id int) *Employee { /* ... */ }fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // "Pointy-haired boss"id := dilbert.IDEmployeeByID(id).Salary = 0 // fired for... no real reasonThelaststatement  updates  theEmployeest ruc tthat  ispoint edtobythe  resultofthe  cal ltoEmployeeByID.Ifthe  resulttyp eofEmployeeByIDwere  change dtoEmployeeinsteadof*Employee,the  assig nmentstatement  wou ldnot  compi lesince  its  left-handside  wou ldnotidentify a var iable.Fieldsare usu allywritt enone per line, wit hthe field’snamepre cedingits typ e,but con sec utivefields ofthe sametyp emaybecom bine d,aswit hNameandAddresshere:The Go Programming Language© 2016 Alan A. A. Donovan & Brian W. Kernighanrevision 3b600c, date 29 Sep 2015
